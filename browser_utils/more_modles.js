// ==UserScript==
// @name         Google AI Studio Model Enjeksiyonu
// @namespace    http://tampermonkey.net/
// @version      1.6.5
// @description  Google AI Studio'ya Ã¶zel modeller ekler, tema ifade simgelerini destekler. XHR/Fetch isteklerini engeller, dizi yapÄ±sÄ±ndaki JSON verilerini iÅŸler
// @author       Generated by AI / HCPTangHY / Mozi / wisdgod / UserModified
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // ==================== YapÄ±landÄ±rma BÃ¶lÃ¼mÃ¼ ====================
    // Script artÄ±k geÃ§ersiz

    const SCRIPT_VERSION = "none";
    const LOG_PREFIX = `[AI Studio Enjeksiyonu ${SCRIPT_VERSION}]`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // Model yapÄ±landÄ±rma listesi
    // jfdksal98a, blacktooth'un altÄ±na yerleÅŸtirildi
    const MODELS_TO_INJECT = [

        // AÅŸaÄŸÄ±daki modellerin tÃ¼mÃ¼ artÄ±k geÃ§ersiz, nostalji iÃ§in burada tutuluyor
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-exp-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-preview-06-05', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/blacktooth-ab-test', displayName: `ðŸ´â€â˜ ï¸ Blacktooth (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/jfdksal98a', displayName: `ðŸª jfdksal98a (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/goldmane-ab-test', displayName: `ðŸ¦ Goldmane (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/claybrook-ab-test', displayName: `ðŸ’§ Claybrook (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/frostwind-ab-test', displayName: `â„ï¸ Frostwind (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` },
        // { name: 'models/calmriver-ab-test', displayName: `ðŸŒŠ Calmriver (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafÄ±ndan enjekte edilen model` }
    ];

    // JSON yapÄ±sÄ±ndaki alan indeksleri
    const MODEL_FIELDS = {
        NAME: 0,
        DISPLAY_NAME: 3,
        DESCRIPTION: 4,
        METHODS: 7
    };

    // ==================== YardÄ±mcÄ± Fonksiyonlar ====================

    /**
     * URL'nin hedef API uÃ§ noktasÄ±na ait olup olmadÄ±ÄŸÄ±nÄ± kontrol eder
     * @param {string} url - Kontrol edilecek URL
     * @returns {boolean}
     */
    function isTargetURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/ListModels');
    }

    /**
     * Model listesi dizisini Ã¶zyinelemeli olarak bulur
     * @param {any} obj - Aranacak nesne
     * @returns {Array|null} Bulunan model dizisi veya null
     */
    function findModelListArray(obj) {
        if (!obj) return null;

        // Hedef model dizisi olup olmadÄ±ÄŸÄ±nÄ± kontrol et
        if (Array.isArray(obj) && obj.length > 0 && obj.every(
            item => Array.isArray(item) &&
                    typeof item[MODEL_FIELDS.NAME] === 'string' &&
                    String(item[MODEL_FIELDS.NAME]).startsWith('models/')
        )) {
            return obj;
        }

        // Alt nesneleri Ã¶zyinelemeli olarak ara
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) &&
                    typeof obj[key] === 'object' &&
                    obj[key] !== null) {
                    const result = findModelListArray(obj[key]);
                    if (result) return result;
                }
            }
        }
        return null;
    }

    /**
     * Uygun ÅŸablon modelini bulur
     * @param {Array} modelsArray - Model dizisi
     * @returns {Array|null} Åžablon modeli veya null
     */
    function findTemplateModel(modelsArray) {
        // Belirli anahtar kelimeleri iÃ§eren modeli Ã¶ncelikle bul
        const templateModel =
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('pro') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('flash') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS]));

        return templateModel;
    }

    /**
     * Mevcut modelin gÃ¶rÃ¼nen adÄ±nÄ± gÃ¼nceller
     * @param {Array} existingModel - Mevcut model
     * @param {Object} modelToInject - Enjekte edilecek model yapÄ±landÄ±rmasÄ±
     * @returns {boolean} GÃ¼ncelleme yapÄ±ldÄ± mÄ±
     */
    function updateExistingModel(existingModel, modelToInject) {
        if (!existingModel || existingModel[MODEL_FIELDS.DISPLAY_NAME] === modelToInject.displayName) {
            return false;
        }

        // Temel adÄ± Ã§Ä±kar (sÃ¼rÃ¼m numarasÄ± ve ifadeler hariÃ§)
        // vX.Y.Z formatÄ±nÄ± eÅŸleÅŸtirmek iÃ§in regex'i gÃ¼ncelle
        const cleanName = (name) => String(name)
            .replace(/ \(Script v\d+\.\d+(\.\d+)?(-beta\d*)?\)/, '')
            // KullanÄ±lan tÃ¼m ifadeleri iÃ§er, yeni eklenenler dahil ðŸ´â€â˜ ï¸, ðŸ¤–, ðŸª
            .replace(/^[âœ¨ðŸ¦ðŸ’§â„ï¸ðŸŒŠðŸ‰ðŸ´â€â˜ ï¸ðŸ¤–ðŸª]\s*/, '')
            .trim();

        const baseExistingName = cleanName(existingModel[MODEL_FIELDS.DISPLAY_NAME]);
        const baseInjectName = cleanName(modelToInject.displayName);

        if (baseExistingName === baseInjectName) {
            // Sadece sÃ¼rÃ¼m numarasÄ±nÄ± ve ifadeyi gÃ¼ncelle
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
            console.log(LOG_PREFIX, `GÃ¼ncellenen ifade/sÃ¼rÃ¼m numarasÄ±: ${modelToInject.displayName}`);
        } else {
            // Orijinal model olarak iÅŸaretle
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName + " (Orijinal)";
            console.log(LOG_PREFIX, `Resmi model ${modelToInject.name} iÃ§in gÃ¶rÃ¼nen ad gÃ¼ncellendi`);
        }
        return true;
    }

    /**
     * Yeni model oluÅŸturur
     * @param {Array} templateModel - Åžablon model
     * @param {Object} modelToInject - Enjekte edilecek model yapÄ±landÄ±rmasÄ±
     * @param {string} templateName - Åžablon adÄ±
     * @returns {Array} Yeni model dizisi
     */
    function createNewModel(templateModel, modelToInject, templateName) {
        const newModel = structuredClone(templateModel);

        newModel[MODEL_FIELDS.NAME] = modelToInject.name;
        newModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
        newModel[MODEL_FIELDS.DESCRIPTION] = `${modelToInject.description} (${templateName} yapÄ±sÄ±na dayanarak)`;

        if (!Array.isArray(newModel[MODEL_FIELDS.METHODS])) {
            newModel[MODEL_FIELDS.METHODS] = [
                "generateContent",
                "countTokens",
                "createCachedContent",
                "batchGenerateContent"
            ];
        }

        return newModel;
    }

    // ==================== Ana Ä°ÅŸleme FonksiyonlarÄ± ====================

    /**
     * JSON verisini iÅŸler ve deÄŸiÅŸtirir
     * @param {Object} jsonData - Orijinal JSON verisi
     * @param {string} url - Ä°stek URL'si
     * @returns {Object} Ä°ÅŸlenmiÅŸ veri ve deÄŸiÅŸtirme iÅŸaretini iÃ§eren nesne
     */
    function processJsonData(jsonData, url) {
        let modificationMade = false;
        const modelsArray = findModelListArray(jsonData);

        if (!modelsArray || !Array.isArray(modelsArray)) {
            console.warn(LOG_PREFIX, 'JSON iÃ§inde geÃ§erli model listesi yapÄ±sÄ± bulunamadÄ±:', url);
            return { data: jsonData, modified: false };
        }

        // Åžablon modeli bul
        const templateModel = findTemplateModel(modelsArray);
        const templateName = templateModel?.[MODEL_FIELDS.NAME] || 'unknown';

        if (!templateModel) {
            console.warn(LOG_PREFIX, 'Yeni model enjekte edilemiyor, uygun ÅŸablon model bulunamadÄ±');
        }

        // GÃ¶rÃ¼ntÃ¼leme sÄ±rasÄ±nÄ± korumak iÃ§in ters sÄ±rada gez (yapÄ±landÄ±rmada Ã¶nde olan model en Ã¼ste gelir)
        [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
            const existingModel = modelsArray.find(
                model => Array.isArray(model) && model[MODEL_FIELDS.NAME] === modelToInject.name
            );

            if (!existingModel) {
                // Yeni model enjekte et
                if (!templateModel) {
                    console.warn(LOG_PREFIX, `${modelToInject.name} enjekte edilemiyor: Åžablon eksik`);
                    return;
                }

                const newModel = createNewModel(templateModel, modelToInject, templateName);
                modelsArray.unshift(newModel); // unshift modeli dizi baÅŸlangÄ±cÄ±na ekler
                modificationMade = true;
                console.log(LOG_PREFIX, `BaÅŸarÄ±yla enjekte edildi: ${modelToInject.displayName}`);
            } else {
                // Mevcut modeli gÃ¼ncelle
                if (updateExistingModel(existingModel, modelToInject)) {
                    modificationMade = true;
                }
            }
        });

        return { data: jsonData, modified: modificationMade };
    }

    /**
     * YanÄ±t gÃ¶vdesini deÄŸiÅŸtirir
     * @param {string} originalText - Orijinal yanÄ±t metni
     * @param {string} url - Ä°stek URL'si
     * @returns {string} DeÄŸiÅŸtirilmiÅŸ yanÄ±t metni
     */
    function modifyResponseBody(originalText, url) {
        if (!originalText || typeof originalText !== 'string') {
            return originalText;
        }

        try {
            let textBody = originalText;
            let hasPrefix = false;

            // KorsanlÄ±k Ã¶nleme Ã¶nekini iÅŸle
            if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                hasPrefix = true;
            }

            if (!textBody.trim()) return originalText;

            const jsonData = JSON.parse(textBody);
            const result = processJsonData(jsonData, url);

            if (result.modified) {
                let newBody = JSON.stringify(result.data);
                if (hasPrefix) {
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                }
                return newBody;
            }
        } catch (error) {
            console.error(LOG_PREFIX, 'YanÄ±t gÃ¶vdesi iÅŸlenirken hata oluÅŸtu:', url, error);
        }

        return originalText;
    }

    // ==================== Ä°stek Engelleme ====================

    // Fetch API'yi engelle
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const resource = args[0];
        const url = (resource instanceof Request) ? resource.url : String(resource);
        const response = await originalFetch.apply(this, args);

        if (isTargetURL(url) && response.ok) {
            console.log(LOG_PREFIX, '[Fetch] Hedef istek engellendi:', url);
            try {
                const cloneResponse = response.clone();
                const originalText = await cloneResponse.text();
                const newBody = modifyResponseBody(originalText, url);

                if (newBody !== originalText) {
                    return new Response(newBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
            } catch (e) {
                console.error(LOG_PREFIX, '[Fetch] Ä°ÅŸleme hatasÄ±:', e);
            }
        }
        return response;
    };

    // XMLHttpRequest'i engelle
    const xhrProto = XMLHttpRequest.prototype;
    const originalOpen = xhrProto.open;
    const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
    const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
    let interceptionCount = 0;

    // open metodunu yeniden yaz
    xhrProto.open = function(method, url) {
        this._interceptorUrl = url;
        this._isTargetXHR = isTargetURL(url);

        if (this._isTargetXHR) {
            interceptionCount++;
            console.log(LOG_PREFIX, `[XHR] Hedef istek algÄ±landÄ± (${interceptionCount})ï¼š`, url);
        }

        return originalOpen.apply(this, arguments);
    };

    /**
     * XHR yanÄ±tÄ±nÄ± iÅŸler
     * @param {XMLHttpRequest} xhr - XHR nesnesi
     * @param {any} originalValue - Orijinal yanÄ±t deÄŸeri
     * @param {string} type - YanÄ±t tÃ¼rÃ¼
     * @returns {any} Ä°ÅŸlenmiÅŸ yanÄ±t deÄŸeri
     */
    const handleXHRResponse = (xhr, originalValue, type = 'text') => {
        if (!xhr._isTargetXHR || xhr.readyState !== 4 || xhr.status !== 200) {
            return originalValue;
        }

        const cacheKey = '_modifiedResponseCache_' + type;

        if (xhr[cacheKey] === undefined) {
            const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null)
                ? String(originalValue || '')
                : JSON.stringify(originalValue);

            xhr[cacheKey] = modifyResponseBody(originalText, xhr._interceptorUrl);
        }

        const cachedResponse = xhr[cacheKey];

        try {
            if (type === 'json' && typeof cachedResponse === 'string') {
                const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX, '');
                return textToParse ? JSON.parse(textToParse) : null;
            }
        } catch (e) {
            console.error(LOG_PREFIX, '[XHR] Ã–nbelleÄŸe alÄ±nan JSON Ã§Ã¶zÃ¼mlenirken hata oluÅŸtu:', e);
            return originalValue;
        }

        return cachedResponse;
    };

    // responseText Ã¶zelliÄŸini yeniden yaz
    if (originalResponseTextDescriptor?.get) {
        Object.defineProperty(xhrProto, 'responseText', {
            get: function() {
                const originalText = originalResponseTextDescriptor.get.call(this);

                if (this.responseType && this.responseType !== 'text' && this.responseType !== "") {
                    return originalText;
                }

                return handleXHRResponse(this, originalText, 'text');
            },
            configurable: true
        });
    }

    // response Ã¶zelliÄŸini yeniden yaz
    if (originalResponseDescriptor?.get) {
        Object.defineProperty(xhrProto, 'response', {
            get: function() {
                const originalResponse = originalResponseDescriptor.get.call(this);

                if (this.responseType === 'json') {
                    return handleXHRResponse(this, originalResponse, 'json');
                }

                if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                    return handleXHRResponse(this, originalResponse, 'text');
                }

                return originalResponse;
            },
            configurable: true
        });
    }

    console.log(LOG_PREFIX, 'Script etkinleÅŸtirildi, Fetch ve XHR engelleme etkin');
})();
