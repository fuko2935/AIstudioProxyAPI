// ==UserScript==
// @name         Google AI Studio Model Enjeksiyonu
// @namespace    http://tampermonkey.net/
// @version      1.6.5
// @description  Google AI Studio'ya özel modeller ekler, tema ifade simgelerini destekler. XHR/Fetch isteklerini engeller, dizi yapısındaki JSON verilerini işler
// @author       Generated by AI / HCPTangHY / Mozi / wisdgod / UserModified
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // ==================== Yapılandırma Bölümü ====================
    // Script artık geçersiz

    const SCRIPT_VERSION = "none";
    const LOG_PREFIX = `[AI Studio Enjeksiyonu ${SCRIPT_VERSION}]`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // Model yapılandırma listesi
    // jfdksal98a, blacktooth'un altına yerleştirildi
    const MODELS_TO_INJECT = [

        // Aşağıdaki modellerin tümü artık geçersiz, nostalji için burada tutuluyor
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `✨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-exp-03-25', displayName: `✨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-preview-06-05', displayName: `✨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/blacktooth-ab-test', displayName: `🏴‍☠️ Blacktooth (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/jfdksal98a', displayName: `🪐 jfdksal98a (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `✨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/goldmane-ab-test', displayName: `🦁 Goldmane (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/claybrook-ab-test', displayName: `💧 Claybrook (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/frostwind-ab-test', displayName: `❄️ Frostwind (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` },
        // { name: 'models/calmriver-ab-test', displayName: `🌊 Calmriver (Script ${SCRIPT_VERSION})`, description: `${SCRIPT_VERSION} scripti tarafından enjekte edilen model` }
    ];

    // JSON yapısındaki alan indeksleri
    const MODEL_FIELDS = {
        NAME: 0,
        DISPLAY_NAME: 3,
        DESCRIPTION: 4,
        METHODS: 7
    };

    // ==================== Yardımcı Fonksiyonlar ====================

    /**
     * URL'nin hedef API uç noktasına ait olup olmadığını kontrol eder
     * @param {string} url - Kontrol edilecek URL
     * @returns {boolean}
     */
    function isTargetURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/ListModels');
    }

    /**
     * Model listesi dizisini özyinelemeli olarak bulur
     * @param {any} obj - Aranacak nesne
     * @returns {Array|null} Bulunan model dizisi veya null
     */
    function findModelListArray(obj) {
        if (!obj) return null;

        // Hedef model dizisi olup olmadığını kontrol et
        if (Array.isArray(obj) && obj.length > 0 && obj.every(
            item => Array.isArray(item) &&
                    typeof item[MODEL_FIELDS.NAME] === 'string' &&
                    String(item[MODEL_FIELDS.NAME]).startsWith('models/')
        )) {
            return obj;
        }

        // Alt nesneleri özyinelemeli olarak ara
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) &&
                    typeof obj[key] === 'object' &&
                    obj[key] !== null) {
                    const result = findModelListArray(obj[key]);
                    if (result) return result;
                }
            }
        }
        return null;
    }

    /**
     * Uygun şablon modelini bulur
     * @param {Array} modelsArray - Model dizisi
     * @returns {Array|null} Şablon modeli veya null
     */
    function findTemplateModel(modelsArray) {
        // Belirli anahtar kelimeleri içeren modeli öncelikle bul
        const templateModel =
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('pro') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('flash') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS]));

        return templateModel;
    }

    /**
     * Mevcut modelin görünen adını günceller
     * @param {Array} existingModel - Mevcut model
     * @param {Object} modelToInject - Enjekte edilecek model yapılandırması
     * @returns {boolean} Güncelleme yapıldı mı
     */
    function updateExistingModel(existingModel, modelToInject) {
        if (!existingModel || existingModel[MODEL_FIELDS.DISPLAY_NAME] === modelToInject.displayName) {
            return false;
        }

        // Temel adı çıkar (sürüm numarası ve ifadeler hariç)
        // vX.Y.Z formatını eşleştirmek için regex'i güncelle
        const cleanName = (name) => String(name)
            .replace(/ \(Script v\d+\.\d+(\.\d+)?(-beta\d*)?\)/, '')
            // Kullanılan tüm ifadeleri içer, yeni eklenenler dahil 🏴‍☠️, 🤖, 🪐
            .replace(/^[✨🦁💧❄️🌊🐉🏴‍☠️🤖🪐]\s*/, '')
            .trim();

        const baseExistingName = cleanName(existingModel[MODEL_FIELDS.DISPLAY_NAME]);
        const baseInjectName = cleanName(modelToInject.displayName);

        if (baseExistingName === baseInjectName) {
            // Sadece sürüm numarasını ve ifadeyi güncelle
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
            console.log(LOG_PREFIX, `Güncellenen ifade/sürüm numarası: ${modelToInject.displayName}`);
        } else {
            // Orijinal model olarak işaretle
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName + " (Orijinal)";
            console.log(LOG_PREFIX, `Resmi model ${modelToInject.name} için görünen ad güncellendi`);
        }
        return true;
    }

    /**
     * Yeni model oluşturur
     * @param {Array} templateModel - Şablon model
     * @param {Object} modelToInject - Enjekte edilecek model yapılandırması
     * @param {string} templateName - Şablon adı
     * @returns {Array} Yeni model dizisi
     */
    function createNewModel(templateModel, modelToInject, templateName) {
        const newModel = structuredClone(templateModel);

        newModel[MODEL_FIELDS.NAME] = modelToInject.name;
        newModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
        newModel[MODEL_FIELDS.DESCRIPTION] = `${modelToInject.description} (${templateName} yapısına dayanarak)`;

        if (!Array.isArray(newModel[MODEL_FIELDS.METHODS])) {
            newModel[MODEL_FIELDS.METHODS] = [
                "generateContent",
                "countTokens",
                "createCachedContent",
                "batchGenerateContent"
            ];
        }

        return newModel;
    }

    // ==================== Ana İşleme Fonksiyonları ====================

    /**
     * JSON verisini işler ve değiştirir
     * @param {Object} jsonData - Orijinal JSON verisi
     * @param {string} url - İstek URL'si
     * @returns {Object} İşlenmiş veri ve değiştirme işaretini içeren nesne
     */
    function processJsonData(jsonData, url) {
        let modificationMade = false;
        const modelsArray = findModelListArray(jsonData);

        if (!modelsArray || !Array.isArray(modelsArray)) {
            console.warn(LOG_PREFIX, 'JSON içinde geçerli model listesi yapısı bulunamadı:', url);
            return { data: jsonData, modified: false };
        }

        // Şablon modeli bul
        const templateModel = findTemplateModel(modelsArray);
        const templateName = templateModel?.[MODEL_FIELDS.NAME] || 'unknown';

        if (!templateModel) {
            console.warn(LOG_PREFIX, 'Yeni model enjekte edilemiyor, uygun şablon model bulunamadı');
        }

        // Görüntüleme sırasını korumak için ters sırada gez (yapılandırmada önde olan model en üste gelir)
        [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
            const existingModel = modelsArray.find(
                model => Array.isArray(model) && model[MODEL_FIELDS.NAME] === modelToInject.name
            );

            if (!existingModel) {
                // Yeni model enjekte et
                if (!templateModel) {
                    console.warn(LOG_PREFIX, `${modelToInject.name} enjekte edilemiyor: Şablon eksik`);
                    return;
                }

                const newModel = createNewModel(templateModel, modelToInject, templateName);
                modelsArray.unshift(newModel); // unshift modeli dizi başlangıcına ekler
                modificationMade = true;
                console.log(LOG_PREFIX, `Başarıyla enjekte edildi: ${modelToInject.displayName}`);
            } else {
                // Mevcut modeli güncelle
                if (updateExistingModel(existingModel, modelToInject)) {
                    modificationMade = true;
                }
            }
        });

        return { data: jsonData, modified: modificationMade };
    }

    /**
     * Yanıt gövdesini değiştirir
     * @param {string} originalText - Orijinal yanıt metni
     * @param {string} url - İstek URL'si
     * @returns {string} Değiştirilmiş yanıt metni
     */
    function modifyResponseBody(originalText, url) {
        if (!originalText || typeof originalText !== 'string') {
            return originalText;
        }

        try {
            let textBody = originalText;
            let hasPrefix = false;

            // Korsanlık önleme önekini işle
            if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                hasPrefix = true;
            }

            if (!textBody.trim()) return originalText;

            const jsonData = JSON.parse(textBody);
            const result = processJsonData(jsonData, url);

            if (result.modified) {
                let newBody = JSON.stringify(result.data);
                if (hasPrefix) {
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                }
                return newBody;
            }
        } catch (error) {
            console.error(LOG_PREFIX, 'Yanıt gövdesi işlenirken hata oluştu:', url, error);
        }

        return originalText;
    }

    // ==================== İstek Engelleme ====================

    // Fetch API'yi engelle
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const resource = args[0];
        const url = (resource instanceof Request) ? resource.url : String(resource);
        const response = await originalFetch.apply(this, args);

        if (isTargetURL(url) && response.ok) {
            console.log(LOG_PREFIX, '[Fetch] Hedef istek engellendi:', url);
            try {
                const cloneResponse = response.clone();
                const originalText = await cloneResponse.text();
                const newBody = modifyResponseBody(originalText, url);

                if (newBody !== originalText) {
                    return new Response(newBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
            } catch (e) {
                console.error(LOG_PREFIX, '[Fetch] İşleme hatası:', e);
            }
        }
        return response;
    };

    // XMLHttpRequest'i engelle
    const xhrProto = XMLHttpRequest.prototype;
    const originalOpen = xhrProto.open;
    const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
    const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
    let interceptionCount = 0;

    // open metodunu yeniden yaz
    xhrProto.open = function(method, url) {
        this._interceptorUrl = url;
        this._isTargetXHR = isTargetURL(url);

        if (this._isTargetXHR) {
            interceptionCount++;
            console.log(LOG_PREFIX, `[XHR] Hedef istek algılandı (${interceptionCount})：`, url);
        }

        return originalOpen.apply(this, arguments);
    };

    /**
     * XHR yanıtını işler
     * @param {XMLHttpRequest} xhr - XHR nesnesi
     * @param {any} originalValue - Orijinal yanıt değeri
     * @param {string} type - Yanıt türü
     * @returns {any} İşlenmiş yanıt değeri
     */
    const handleXHRResponse = (xhr, originalValue, type = 'text') => {
        if (!xhr._isTargetXHR || xhr.readyState !== 4 || xhr.status !== 200) {
            return originalValue;
        }

        const cacheKey = '_modifiedResponseCache_' + type;

        if (xhr[cacheKey] === undefined) {
            const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null)
                ? String(originalValue || '')
                : JSON.stringify(originalValue);

            xhr[cacheKey] = modifyResponseBody(originalText, xhr._interceptorUrl);
        }

        const cachedResponse = xhr[cacheKey];

        try {
            if (type === 'json' && typeof cachedResponse === 'string') {
                const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX, '');
                return textToParse ? JSON.parse(textToParse) : null;
            }
        } catch (e) {
            console.error(LOG_PREFIX, '[XHR] Önbelleğe alınan JSON çözümlenirken hata oluştu:', e);
            return originalValue;
        }

        return cachedResponse;
    };

    // responseText özelliğini yeniden yaz
    if (originalResponseTextDescriptor?.get) {
        Object.defineProperty(xhrProto, 'responseText', {
            get: function() {
                const originalText = originalResponseTextDescriptor.get.call(this);

                if (this.responseType && this.responseType !== 'text' && this.responseType !== "") {
                    return originalText;
                }

                return handleXHRResponse(this, originalText, 'text');
            },
            configurable: true
        });
    }

    // response özelliğini yeniden yaz
    if (originalResponseDescriptor?.get) {
        Object.defineProperty(xhrProto, 'response', {
            get: function() {
                const originalResponse = originalResponseDescriptor.get.call(this);

                if (this.responseType === 'json') {
                    return handleXHRResponse(this, originalResponse, 'json');
                }

                if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                    return handleXHRResponse(this, originalResponse, 'text');
                }

                return originalResponse;
            },
            configurable: true
        });
    }

    console.log(LOG_PREFIX, 'Script etkinleştirildi, Fetch ve XHR engelleme etkin');
})();
